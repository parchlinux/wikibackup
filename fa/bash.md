---
title: پوسته Bash
description: 
published: true
date: 2025-01-05T16:27:50.157Z
tags: bash
editor: markdown
dateCreated: 2025-01-05T13:37:50.828Z
---

# پوسته Bash
Bash (پوستهٔ بورن-دوباره) یک پوستهٔ خط فرمان/زبان برنامه‌نویسی است که توسط پروژهٔ گنو توسعه یافته است. نام آن به پیشینی خود، پوستهٔ بورن که مدت‌هاست منسوخ شده، اشاره دارد. Bash می‌تواند بر روی اکثر سیستم‌عامل‌های شبیه یونیکس، از جمله گنو/لینوکس، اجرا شود.

>در توزیع پارچ، پوستهٔ bash به عنوان پوستهٔ پیشفرض استفاده می‌شود. 
{.is-info}

## فراخوانی
رفتار Bash می‌تواند بسته به نحوهٔ فراخوانی آن تغییر کند. در زیر توضیحاتی دربارهٔ حالت‌های مختلف آمده است.

اگر Bash از طریق ورود به یک TTY، توسط یک دیمون SSH یا روش‌های مشابه راه‌اندازی شود، به آن پوستهٔ ورود (login shell) گفته می‌شود. این حالت همچنین می‌تواند با استفاده از گزینهٔ خط فرمان  -l یا --login فعال شود.

Bash زمانی که ورودی، خروجی و خطای استاندارد آن به یک ترمینال متصل باشد (برای مثال، زمانی که در یک شبیه‌ساز ترمینال اجرا می‌شود) و با گزینهٔ -c یا آرگومان‌های غیرگزینه‌ای (برای مثال، bash script) شروع نشود، به عنوان یک پوستهٔ تعاملی (interactive shell) در نظر گرفته می‌شود. تمام پوسته‌های تعاملی فایل‌های /etc/bash ، .bashrc و ~/.bashrc را بارگذاری می‌کنند، در حالی که پوسته‌های تعاملی ورود همچنین فایل‌های /etc/profile و ~/.bash_profile را نیز بارگذاری می‌کنند.

>**توجه:** در پارچ، /bin/sh (که قبلاً به عنوان اجرایی شل بورن استفاده می‌شد) به bash لینک نمادین شده است. اگر Bash با نام sh فراخوانی شود، سعی می‌کند رفتار راه‌اندازی نسخه‌های تاریخی sh را تقلید کند، از جمله سازگاری با POSIX. 
{.is-info}

### پروندهٔ‌های پیکربندی
Bash سعی خواهد کرد مجموعه‌ای از فایل‌های راه‌اندازی را بسته به نحوهٔ فراخوانی آن اجرا کند. 

| پرونده                  | توضیحات                                                                 | پوسته‌های ورود (به یاد داشته باشید) | پوسته‌های تعاملی غیر ورود |
|-----------------------|-------------------------------------------------------------------------|-------------------------------------|---------------------------|
| /etc/profile          | تنظیمات برنامه‌ها را در /etc/profile.d/*.sh و /etc/bash.bashrc بارگذاری می‌کند. | بله                                 | خیر                       |
| ~/.bash_profile       | برای هر کاربر، پس از /etc/profile. اگر این فایل وجود نداشته باشد، به ترتیب ~/.bash_login و ~/.profile بررسی می‌شوند. فایل الگو /etc/skel/.bash_profile همچنین ~/.bashrc را بارگذاری می‌کند. | بله                                 | خیر                       |
| ~/.bash_logout        | برای هر کاربر، پس از خروج از یک پوستهٔ ورود.                             | بله                                 | خیر                       |
| /etc/bash.bash_logout | بستگی به پرچم کامپایل -DSYS_BASH_LOGOUT="/etc/bash.bash_logout" دارد. پس از خروج از یک پوستهٔ ورود. | بله                                 | خیر                       |
| /etc/bash.bashrc     | بستگی به پرچم کامپایل -DSYS_BASHRC="/etc/bash.bashrc" دارد. /usr/share/bash-completion/bash_completion را بارگذاری می‌کند. | خیر                                 | بله                       |
| ~/.bashrc             | برای هر کاربر، پس از /etc/bash یا .bashrc.                                   | خیر                                 | بله                       |


>**توجه**:
پوسته‌های ورود می‌توانند زمانی که با آرگومان --login فراخوانی شوند، غیرتعامل‌پذیر (non-interactive) باشند. در حالی که پوسته‌های تعاملی غیر ورود، فایل ~/.bash_profile را بارگذاری نمی‌کنند، اما همچنان محیط را از فرآیند والد خود (که ممکن است یک پوستهٔ ورود باشد) به ارث می‌برند. 
{.is-info}

### پوسته و متغیرهای محیطی

رفتار Bash و برنامه‌هایی که توسط آن اجرا می‌شوند، می‌تواند تحت تأثیر تعدادی از متغیرهای محیطی قرار گیرد. متغیرهای محیطی برای ذخیرهٔ مقادیر مفید مانند دایرکتوری‌های جستجوی فرمان یا مرورگری که باید استفاده شود، به کار می‌روند. زمانی که یک پوسته یا اسکریپت جدید راه‌اندازی می‌شود، متغیرهای والد خود را به ارث می‌برد و بنابراین با یک مجموعه داخلی از متغیرهای پوسته شروع می‌کند.

این متغیرهای پوسته در Bash می‌توانند صادر شوند تا به متغیرهای محیطی تبدیل شوند:
```bash
VARIABLE=content
export VARIABLE
```
یا با یک میانبر:
```bash
export VARIABLE=content
```
متغیرهای محیطی به طور معمول در `~/.profile` یا `/etc/profile` قرار می‌گیرند تا سایر پوسته‌های سازگار با بورن نیز بتوانند از آن‌ها استفاده کنند.

----
## خط فرمان
خط فرمان Bash توسط کتابخانه‌ای جداگانه به نام Readline مدیریت می‌شود. Readline سبک‌های میانبر emacs و vi را برای تعامل با خط فرمان فراهم می‌کند، به عبارت دیگر، امکان حرکت به جلو و عقب بر اساس کلمات، حذف کلمات و غیره را فراهم می‌آورد. همچنین، مدیریت تاریخچهٔ دستورات ورودی نیز بر عهدهٔ Readline است. در نهایت، این کتابخانه به شما اجازه می‌دهد تا ماکروها را ایجاد کنید.

### تکمیل‌خودکار با کلید tab
تکمیل خودکار با کلید <kbd>Tab</kbd> گزینه‌ای است برای تکمیل خودکار دستورات تایپ شده با فشار دادن کلید <kbd>Tab</kbd> (که به طور پیش‌فرض فعال است).

#### برنامه‌ها و گزینه‌های رایج
به طور پیش‌فرض، Bash فقط دستورات، نام فایل‌ها و متغیرها را با استفاده از کلید <kbd>Tab</kbd> تکمیل می‌کند. بستهٔ `bash-completion` این قابلیت را گسترش می‌دهد و تکمیل‌های خودکار تخصصی‌تری را برای دستورات رایج و گزینه‌های آن‌ها اضافه می‌کند، که می‌توان با بارگذاری فایل `/usr/share/bash-completion/bash_completion`(که قبلاً در /etc/bash یا .bashrc پارچ بارگذاری شده است) آن را فعال کرد. با استفاده از bash-completion، تکمیل‌های معمولی (مانند ls file.* Tab Tab) رفتار متفاوتی خواهند داشت؛ با این حال، می‌توان آن‌ها را با استفاده از دستور `compopt -o bashdefault program` دوباره فعال کرد .

#### سفارشی‌سازی برای هر دستور

> توجه: استفاده از دستور `complete` ممکن است با bash-completion تداخل ایجاد کند.  
{.is-info}

به طور پیش‌فرض، Bash فقط نام فایل‌ها را پس از یک دستور با استفاده از کلید Tab تکمیل می‌کند.
می‌توانید آن را تغییر دهید تا نام دستورات را نیز با استفاده از `complete -c` تکمیل کند:

```bash
‎~/.bashrc
-----
complete -c man which
```

یا می‌توانید نام دستورات و نام فایل‌ها را با استفاده از گزینه `-cf` تکمیل کنید:

```bash
complete -cf sudo
```

برای گزینه‌های بیشتر در مورد تکمیل، به بخش "§ Programmable Completion" در مستندات bash(1) مراجعه کنید.


### تاریخچه
#### تکمیل از تاریخچه
شما می‌تونید با بایند کردن کلید‌های جهت بالا و پایین در تاریخچه پوستهٔ بش جابه‌جا بشید:
```bash
bind '"\e[A": history-search-backward'
bind '"\e[B": history-search-forward'
```
برای تحت تأثیر قراردادن همه برنامه‌های readline:
در فایل .inputrc:
```bash
"\e[A": history-search-backward
"\e[B": history-search-forward
```

#### شخصی‌سازی تاریخچه
مقدار `HISTCONTROL` می‌تواند باعث شود تا یک سری دستور خاص در تاریخچه ثبت نشوند. برای مثال
برای متوقف کردن ثبت دستورهای متوالی مشابه:
```bash
‎~/.bashrc
------
export HISTCONTROL=ignoredups
```
برای حذف تمام دستورات مشابه به جز آخرین دستور:
```bash
‎~/.bashrc
------
export HISTCONTROL=erasedups
```
برای جلوگیری از ذخیرهٔ دستورات که با یک فاصله شروع می‌شوند:
```bash
‎~/.bashrc
------
export HISTCONTROL=ignorespace
```
برای جلوگیری از ذخیرهٔ دستورات مشابه متوالی و دستورات که با یک فاصله شروع می‌شوند:
```bash
‎~/.bashrc
------
export HISTCONTROL=ignoreboth
```
برای حذف تمام دستورات مشابه به جز آخرین دستور و دستورات که با یک فاصله شروع می‌شوند:
```bash
‎~/.bashrc
------
export HISTCONTROL="erasedups:ignorespace"
```
به bash(1) § HISTCONTROL برای جزئیات بیشتر مراجعه کنید.

#### غیرفعال کردن تاریخچه
برای غیرفعال کردن تاریخچه به صورت موقت از دستور زیر استفاده کنید:
```bash
set +o history
```
این دستور به صورت موقت نوشتن تاریخچه را در پروندهٔ `$HISTFILE` متوقف می‌کند.

به عنوان مثال، اکنون می‌توانید پسوردها را با استفاده از دستور `printf secret | sha256sum` هش کنید، یا استفاده از GPG را با دستور `gpg -eaF secret-pubkey.asc` پنهان کنید و در این صورت رمز شما بر روی دیسک نوشته نخواهد شد.

برای فعال‌سازی تاریخچه:

```bash
$ set -o history
```

برای غیرفعال کردن تمام تاریخچهٔ Bash:

در پروندهٔ `~/.bashrc` یا `/etc/profile`:

```bash
export HISTSIZE=0
```

... و فقط برای اطمینان، پروندهٔ تاریخچهٔ قدیمی خود را برای همیشه نابود کنید:

```bash
wipe -i -l2 -x4 -p4 "$HISTFILE" 
ln -sv /dev/null "$HISTFILE"
```

### شبیه‌سازی قابلیت run-help Zsh

Zsh می‌تواند با فشار دادن Alt+h، راهنمای مربوط به دستوری که قبل از نشانگر (کرسر) قرار دارد را فراخوانی کند. رفتار مشابهی در Bash با استفاده از این دستور Readline به دست می‌آید:

در پروندهٔ `~/.bashrc`:

```bash
run-help() { help "$READLINE_LINE" 2>/dev/null || man "$READLINE_LINE"; }
bind -m vi-insert -x '"\eh": run-help'
bind -m emacs -x     '"\eh": run-help'
```

فرض می‌شود که شما قادر به استفاده از حالت ویرایش Emacs (که به طور پیش‌فرض است) هستید.

### به اشتراک‌گذاری تاریخچه Bash در بین ماشین‌ها

Atuin تاریخچهٔ شل موجود شما را با یک پایگاه داده SQLite جایگزین می‌کند و زمینه‌های اضافی برای دستورات شما را ثبت می‌کند. علاوه بر این، امکان همگام‌سازی اختیاری و کاملاً رمزگذاری شدهٔ تاریخچهٔ شما بین ماشین‌ها را از طریق یک سرور Atuin فراهم می‌کند.

قبل از همگام‌سازی، زمان‌بندی تاریخچهٔ Bash را فعال کنید (با استفاده از دستور `export HISTTIMEFORMAT="%F %T "`). Atuin به خوبی با ابزارهایی مانند blesh-gitAUR و cmd-wrapped کار می‌کند تا تجربهٔ پایانه بهتری را در بین ماشین‌ها فراهم کند.

## نام مستعار (Aliases)

`alias` یک دستور است که امکان جایگزینی یک کلمه با یک رشتهٔ دیگر را فراهم می‌کند. این دستور معمولاً برای کوتاه کردن یک دستور سیستم یا افزودن آرگومان‌های پیش‌فرض به یک دستور که به طور منظم استفاده می‌شود، به کار می‌رود.

نام‌های مستعار شخصی می‌توانند در فایل `~/.bashrc` یا هر فایل جداگانه‌ای که از `~/.bashrc` بارگذاری می‌شود، ذخیره شوند. نام‌های مستعار سراسری (که بر تمام کاربران تأثیر می‌گذارند) باید در فایل `/etc/bash.bashrc` قرار گیرند. 


## نکات و ترفندها


### هایلایت سینتکس و پیشنهادات خودکار
`ble.sh` (ویرایشگر خط Bash)، که به عنوان ^AUR^`blesh-git` بسته‌بندی شده است، یک ویرایشگر خط فرمان نوشته شده به زبان Bash خالص است که جایگزینی برای GNU Readline به شمار می‌رود. این ابزار دارای ویژگی‌های پیشرفته‌ای مانند هایلایت سینتکس، پیشنهادات خودکار، تکمیل منویی، اختصارات، حالت ویرایش Vim و توابع hook است. سایر ویژگی‌های جالب شامل خط وضعیت، اشتراک تاریخچه، پرامپت راست، پرامپت موقتی و عنوان xterm می‌باشد.

پس از نصب آن، در یک جلسه تعاملی بارگذاری کنید:

```bash
‎~/.bashrc
source /usr/share/blesh/ble.sh
```

تنظیمات به طور عمیق در فایل `~/.blerc` و در ویکی توضیح داده شده است. بستهٔ پایدار ^AUR^`blesh` نیز در دسترس است.

### دستور پیدا نشد
`pkgfile` شامل یک hook "دستور پیدا نشد" است که به طور خودکار در هنگام وارد کردن یک دستور ناشناخته، به جستجوی مخازن رسمی می‌پردازد.

برای فعال‌سازی این hook، باید آن را بارگذاری کنید، به عنوان مثال:

```bash
‎~/.bashrc
source /usr/share/doc/pkgfile/command-not-found.bash
```

سپس تلاش برای اجرای یک دستور غیرقابل دسترسی، اطلاعات زیر را نمایش می‌دهد:

```bash
‎$ abiword
abiword may be found in the following packages:
  extra/abiword 3.0.1-2	/usr/bin/abiword
```

> **توجه**: ممکن است نیاز باشد که پایگاه داده pkgfile قبل از کارکرد این ویژگی به‌روزرسانی شود.  {.is-warning}

غیرفعال کردن Ctrl+z در ترمینال

شما می‌توانید ویژگی <kbd>Ctrl+z</kbd> (که برنامه شما را متوقف یا می‌بندد) را با استفاده از کد زیر غیرفعال کنید:

```bash
‎#!/bin/bash
trap "" 20
adom
```

اکنون، وقتی به طور تصادفی <kbd>Ctrl+z</kbd> را در `adom`^AUR^ فشار می‌دهید به جای <kbd>Shift+z</kbd>، هیچ اتفاقی نخواهد افتاد زیرا <kbd>Ctrl+z</kbd> نادیده گرفته می‌شود.

### پاک کردن صفحه پس از خروج

برای پاک کردن صفحه پس از خروج از یک ترمینال مجازی:

```bash
‎~/.bash_logout
clear
reset
```

### "cd" خودکار هنگام وارد کردن فقط یک مسیر

Bash می‌تواند به طور خودکار `cd` را هنگام وارد کردن فقط یک مسیر در شل اضافه کند. به عنوان مثال:

```bash
‎$ /etc
bash: /etc: Is a directory
```

اما پس از افزودن یک خط به فایل `.bashrc`:

```bash
‎~/.bashrc
...
shopt -s autocd
...
```

شما به این صورت خواهید داشت:

```bash
‎[user@host ~]$ /etc
cd /etc
‎[user@host etc]$
```

### Autojump

`autojump-git`^AUR^ یک اسکریپت پایتون است که به شما اجازه می‌دهد با جستجوی رشته‌ها در یک پایگاه داده از مسیرهای پر بازدید کاربر، در سیستم فایل ناوبری کنید.

`zoxide` یک جایگزین است که ویژگی‌ها و بهبودهای عملکردی بیشتری نسبت به `autojump` اصلی دارد و می‌تواند به عنوان یک جایگزین مستقیم برای `autojump` عمل کند.

### جلوگیری از بازنویسی فایل‌ها

برای جلسهٔ جاری، برای جلوگیری از بازنویسی فایل‌های عادی موجود توسط هدایت خروجی شل:

```bash
‎$ set -o noclobber
```

این معادل `set -C` است.

برای پایدار کردن تغییرات برای کاربر خود:

```bash
‎~/.bashrc
...
‎set -o noclobber
```

برای بازنویسی دستی یک فایل در حالی که `noclobber` فعال است:

```bash
‎$ echo "output" >| file.txt
```

### استفاده از پشته دایرکتوری برای ناوبری

دستورات `pushd` و `popd` می‌توانند برای اضافه کردن یا حذف دایرکتوری‌ها به یک پشته در حین جابجایی به آن‌ها استفاده شوند. این می‌تواند برای "پخش مجدد" تاریخچهٔ ناوبری شما مفید باشد.

```bash
‎[user@host ~] pushd /tmp/dir1
‎[user@host /tmp/dir1] pushd /var/lib
‎[user@host /var/lib] popd
‎[user@host /tmp/dir1] popd
‎[user@host ~]
```

برای اطلاعات بیشتر به bash(1) § DIRSTACK مراجعه کنید.
